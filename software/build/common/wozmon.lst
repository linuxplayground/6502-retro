ca65 V2.18 - Ubuntu 2.18-1
Main file   : common/src/wozmon.s
Current file: common/src/wozmon.s

000000r 1                       .include "zeropage.inc"
000000r 2                       .globalzp usr_irq
000000r 2                       .globalzp con_r_idx
000000r 2                       .globalzp con_w_idx
000000r 2                       .globalzp str_ptr
000000r 2                       .globalzp tmp1
000000r 2                       .globalzp crc
000000r 2                       .globalzp crch
000000r 2                       .globalzp ptr
000000r 2                       .globalzp ptrh
000000r 2                       .globalzp blkno
000000r 2                       .globalzp retry
000000r 2                       .globalzp retry2
000000r 2                       .globalzp bflag
000000r 2                       .globalzp XAML
000000r 2                       .globalzp XAMH
000000r 2                       .globalzp STL
000000r 2                       .globalzp STH
000000r 2                       .globalzp L
000000r 2                       .globalzp H
000000r 2                       .globalzp YSAV
000000r 2                       .globalzp MODE
000000r 2                       .globalzp MSGL
000000r 2                       .globalzp MSGH
000000r 2               
000000r 1                       .include "console.inc"
000000r 2                       .import _con_init
000000r 2                       .import _con_in
000000r 2                       .import _con_out
000000r 2                       .import _con_prompt
000000r 2                       .import _con_nl
000000r 2                       .import _con_print
000000r 2               
000000r 1                       .include "sysram.inc"
000000r 2                       .import con_buf
000000r 2                       .import Rbuff
000000r 2                       .import wozmon_buf
000000r 2               
000000r 1               
000000r 1                       .export _wozmon
000000r 1                       .export _prbyte
000000r 1               
000000r 1               IN      = wozmon_buf    ;*Input buffer (Sysram)
000000r 1               
000000r 1                       .code
000000r 1               
000000r 1               _wozmon:
000000r 1               RESET:
000000r 1  D8                   CLD             ;Clear decimal arithmetic mode.
000001r 1  58                   CLI
000002r 1  A9 0D                LDA #$0D
000004r 1  20 rr rr             JSR ECHO        ;* New line.
000007r 1  A9 0A                LDA #$0A
000009r 1  20 rr rr             JSR ECHO
00000Cr 1  A9 rr                LDA #<MSG1
00000Er 1  85 rr                STA MSGL
000010r 1  A9 rr                LDA #>MSG1
000012r 1  85 rr                STA MSGH
000014r 1  20 rr rr             JSR SHWMSG      ;* Show Welcome.
000017r 1  A9 0D                LDA #$0D
000019r 1  20 rr rr             JSR ECHO        ;* New line.
00001Cr 1  A9 0A                LDA #$0A
00001Er 1  20 rr rr             JSR ECHO
000021r 1               SOFTRESET:
000021r 1  A9 9B                LDA #$9B        ;* Auto escape.
000023r 1               NOTCR:
000023r 1  C9 88                CMP #$88        ;"<-"? * Note this was chaged to $88 which is the back space key.
000025r 1  F0 18                BEQ BACKSPACE   ;Yes.
000027r 1  C9 9B                CMP #$9B        ;ESC?
000029r 1  F0 03                BEQ ESCAPE      ;Yes.
00002Br 1  C8                   INY             ;Advance text index.
00002Cr 1  10 1E                BPL NEXTCHAR    ;Auto ESC if >127.
00002Er 1               ESCAPE:
00002Er 1  A9 DC                LDA #$DC        ;"\"
000030r 1  20 rr rr             JSR ECHO        ;Output it.
000033r 1               GETLINE:
000033r 1  A9 8D                LDA #$8D        ;CR.
000035r 1  20 rr rr             JSR ECHO        ;Output it.
000038r 1  A9 8A                LDA #$8A
00003Ar 1  20 rr rr             JSR ECHO
00003Dr 1  A0 01                LDY #$01        ;Initiallize text index.
00003Fr 1               BACKSPACE:
00003Fr 1  88                   DEY             ;Backup text index.
000040r 1  30 F1                BMI GETLINE     ;Beyond start of line, reinitialize.
000042r 1  A9 A0                LDA #$A0        ;*Space, overwrite the backspaced char.
000044r 1  20 rr rr             JSR ECHO
000047r 1  A9 88                LDA #$88        ;*Backspace again to get to correct pos.
000049r 1  20 rr rr             JSR ECHO
00004Cr 1               NEXTCHAR:
00004Cr 1  20 rr rr             JSR _con_in
00004Fr 1  90 FB                BCC NEXTCHAR
000051r 1  C9 60                CMP #$60        ;*Is it Lower case
000053r 1  30 02                BMI   CONVERT   ;*Nope, just convert it
000055r 1  29 5F                AND #$5F        ;*If lower case, convert to Upper case
000057r 1               CONVERT:
000057r 1  09 80                ORA #$80        ;*Convert it to "ASCII Keyboard" Input
000059r 1  99 rr rr             STA IN,Y        ;Add to text buffer.
00005Cr 1  20 rr rr             JSR ECHO        ;Display character.
00005Fr 1  C9 8D                CMP #$8D        ;CR?
000061r 1  D0 C0                BNE NOTCR       ;No.
000063r 1  A0 FF                LDY #$FF        ;Reset text index.
000065r 1  A9 00                LDA #$00        ;For XAM mode.
000067r 1  AA                   TAX             ;0->X.
000068r 1               SETSTOR:
000068r 1  0A                   ASL             ;Leaves $7B if setting STOR mode.
000069r 1               SETMODE:
000069r 1  85 rr                STA MODE        ;$00 = XAM, $7B = STOR, $AE = BLOK XAM.
00006Br 1               BLSKIP:
00006Br 1  C8                   INY             ;Advance text index.
00006Cr 1               NEXTITEM:
00006Cr 1  B9 rr rr             LDA IN,Y        ;Get character.
00006Fr 1  C9 8D                CMP #$8D        ;CR?
000071r 1  F0 C0                BEQ GETLINE     ;Yes, done this line.
000073r 1  C9 AE                CMP #$AE        ;"."?
000075r 1  90 F4                BCC BLSKIP      ;Skip delimiter.
000077r 1  F0 F0                BEQ SETMODE     ;Set BLOCK XAM mode.
000079r 1  C9 BA                CMP #$BA        ;":"?
00007Br 1  F0 EB                BEQ SETSTOR     ;Yes, set STOR mode.
00007Dr 1  C9 D1                CMP #$D1        ;"Q"?
00007Fr 1  F0 31                BEQ EXIT
000081r 1  C9 D2                CMP #$D2        ;"R"?
000083r 1  F0 2E                BEQ RUN         ;Yes, run user program.
000085r 1  86 rr                STX L           ;$00->L.
000087r 1  86 rr                STX H           ; and H.
000089r 1  84 rr                STY YSAV        ;Save Y for comparison.
00008Br 1               NEXTHEX:
00008Br 1  B9 rr rr             LDA IN,Y        ;Get character for hex test.
00008Er 1  49 B0                EOR #$B0        ;Map digits to $0-9.
000090r 1  C9 0A                CMP #$0A        ;Digit?
000092r 1  90 06                BCC DIG         ;Yes.
000094r 1  69 88                ADC #$88        ;Map letter "A"-"F" to $FA-FF.
000096r 1  C9 FA                CMP #$FA        ;Hex letter?
000098r 1  90 11                BCC NOTHEX      ;No, character not hex.
00009Ar 1               DIG:
00009Ar 1  0A                   ASL
00009Br 1  0A                   ASL             ;Hex digit to MSD of A.
00009Cr 1  0A                   ASL
00009Dr 1  0A                   ASL
00009Er 1  A2 04                LDX #$04        ;Shift count.
0000A0r 1               HEXSHIFT:
0000A0r 1  0A                   ASL             ;Hex digit left MSB to carry.
0000A1r 1  26 rr                ROL L           ;Rotate into LSD.
0000A3r 1  26 rr                ROL H           ;Rotate into MSD's.
0000A5r 1  CA                   DEX             ;Done 4 shifts?
0000A6r 1  D0 F8                BNE HEXSHIFT    ;No, loop.
0000A8r 1  C8                   INY             ;Advance text index.
0000A9r 1  D0 E0                BNE NEXTHEX     ;Always taken. Check next character for hex.
0000ABr 1               NOTHEX:
0000ABr 1  C4 rr                CPY YSAV        ;Check if L, H empty (no hex digits).
0000ADr 1  D0 0D                BNE NOESCAPE    ;* Branch out of range, had to improvise...
0000AFr 1  4C rr rr             JMP ESCAPE      ;Yes, generate ESC sequence.
0000B2r 1               
0000B2r 1               EXIT:
0000B2r 1  60                   RTS             ; back to bootloader
0000B3r 1               
0000B3r 1               RUN:
0000B3r 1  20 rr rr             JSR ACTRUN      ;* JSR to the Address we want to run.
0000B6r 1  4C rr rr             JMP   SOFTRESET ;* When returned for the program, reset EWOZ.
0000B9r 1               ACTRUN:
0000B9r 1  6C rr rr             JMP (XAML)      ;Run at current XAM index.
0000BCr 1               
0000BCr 1               NOESCAPE:
0000BCr 1  24 rr                BIT MODE        ;Test MODE byte.
0000BEr 1  50 0D                BVC NOTSTOR     ;B6=0 for STOR, 1 for XAM and BLOCK XAM
0000C0r 1  A5 rr                LDA L           ;LSD's of hex data.
0000C2r 1  81 rr                STA (STL, X)    ;Store at current "store index".
0000C4r 1  E6 rr                INC STL         ;Increment store index.
0000C6r 1  D0 A4                BNE NEXTITEM    ;Get next item. (no carry).
0000C8r 1  E6 rr                INC STH         ;Add carry to 'store index' high order.
0000CAr 1               TONEXTITEM:
0000CAr 1  4C rr rr             JMP NEXTITEM    ;Get next command item.
0000CDr 1               NOTSTOR:
0000CDr 1  30 30                BMI XAMNEXT     ;B7=0 for XAM, 1 for BLOCK XAM.
0000CFr 1  A2 02                LDX #$02        ;Byte count.
0000D1r 1               SETADR:
0000D1r 1  B5 rr                LDA L-1,X       ;Copy hex data to
0000D3r 1  95 rr                STA STL-1,X     ;"store index".
0000D5r 1  95 rr                STA XAML-1,X    ;And to "XAM index'.
0000D7r 1  CA                   DEX             ;Next of 2 bytes.
0000D8r 1  D0 F7                BNE SETADR      ;Loop unless X = 0.
0000DAr 1               NXTPRNT:
0000DAr 1  D0 19                BNE PRDATA      ;NE means no address to print.
0000DCr 1  A9 8D                LDA #$8D        ;CR.
0000DEr 1  20 rr rr             JSR ECHO        ;Output it.
0000E1r 1  A9 8A                LDA #$8A
0000E3r 1  20 rr rr             JSR ECHO
0000E6r 1  A5 rr                LDA XAMH        ;'Examine index' high-order byte.
0000E8r 1  20 rr rr             JSR PRBYTE      ;Output it in hex format.
0000EBr 1  A5 rr                LDA XAML        ;Low-order "examine index" byte.
0000EDr 1  20 rr rr             JSR PRBYTE      ;Output it in hex format.
0000F0r 1  A9 BA                LDA #$BA        ;":".
0000F2r 1  20 rr rr             JSR ECHO        ;Output it.
0000F5r 1               PRDATA:
0000F5r 1  A9 A0                LDA #$A0        ;Blank.
0000F7r 1  20 rr rr             JSR ECHO        ;Output it.
0000FAr 1  A1 rr                LDA (XAML,X)    ;Get data byte at 'examine index".
0000FCr 1  20 rr rr             JSR PRBYTE      ;Output it in hex format.
0000FFr 1               XAMNEXT:
0000FFr 1  86 rr                STX MODE        ;0-> MODE (XAM mode).
000101r 1  A5 rr                LDA XAML
000103r 1  C5 rr                CMP L           ;Compare 'examine index" to hex data.
000105r 1  A5 rr                LDA XAMH
000107r 1  E5 rr                SBC H
000109r 1  B0 BF                BCS TONEXTITEM  ;Not less, so no more data to output.
00010Br 1  E6 rr                INC XAML
00010Dr 1  D0 02                BNE MOD8CHK     ;Increment 'examine index".
00010Fr 1  E6 rr                INC XAMH
000111r 1               MOD8CHK:
000111r 1  A5 rr                LDA XAML        ;Check low-order 'exainine index' byte
000113r 1  29 0F                AND #$0F        ;For MOD 8=0 ** changed to $0F to get 16 values per row **
000115r 1  10 C3                BPL NXTPRNT     ;Always taken.
000117r 1               _prbyte:
000117r 1               PRBYTE:
000117r 1  48                   PHA             ;Save A for LSD.
000118r 1  4A                   LSR
000119r 1  4A                   LSR
00011Ar 1  4A                   LSR             ;MSD to LSD position.
00011Br 1  4A                   LSR
00011Cr 1  20 rr rr             JSR PRHEX       ;Output hex digit.
00011Fr 1  68                   PLA             ;Restore A.
000120r 1               PRHEX:
000120r 1  29 0F                AND #$0F        ;Mask LSD for hex print.
000122r 1  09 B0                ORA #$B0        ;Add "0".
000124r 1  C9 BA                CMP #$BA        ;Digit?
000126r 1  90 02                BCC ECHO        ;Yes, output it.
000128r 1  69 06                ADC #$06        ;Add offset for letter.
00012Ar 1               ECHO:
00012Ar 1  48                   PHA             ;*Save A
00012Br 1  29 7F                AND #$7F        ;*Change to "standard ASCII"
00012Dr 1  20 rr rr             JSR _con_out
000130r 1  68                   PLA             ;*Restore A
000131r 1  60                   RTS             ;*Done, over and out...
000132r 1               
000132r 1               SHWMSG:
000132r 1  A0 00                LDY #$0
000134r 1               @PRINT:
000134r 1  B1 rr                LDA (MSGL),Y
000136r 1  F0 06                BEQ @DONE
000138r 1  20 rr rr             JSR ECHO
00013Br 1  C8                   INY
00013Cr 1  D0 F6                BNE @PRINT
00013Er 1               @DONE:
00013Er 1  60                   RTS
00013Fr 1               
00013Fr 1               
00013Fr 1  57 65 6C 63  MSG1:      .BYTE "Welcome to EWOZ 1.0.",0
000143r 1  6F 6D 65 20  
000147r 1  74 6F 20 45  
000153r 1               
