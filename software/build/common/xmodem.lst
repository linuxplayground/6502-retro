ca65 V2.18 - Ubuntu 2.18-1
Main file   : common/src/xmodem.s
Current file: common/src/xmodem.s

000000r 1                       .include "zeropage.inc"
000000r 2                       .globalzp usr_irq
000000r 2                       .globalzp con_r_idx
000000r 2                       .globalzp con_w_idx
000000r 2                       .globalzp str_ptr
000000r 2                       .globalzp tmp1
000000r 2                       .globalzp crc
000000r 2                       .globalzp crch
000000r 2                       .globalzp ptr
000000r 2                       .globalzp ptrh
000000r 2                       .globalzp blkno
000000r 2                       .globalzp retry
000000r 2                       .globalzp retry2
000000r 2                       .globalzp bflag
000000r 2                       .globalzp XAML
000000r 2                       .globalzp XAMH
000000r 2                       .globalzp STL
000000r 2                       .globalzp STH
000000r 2                       .globalzp L
000000r 2                       .globalzp H
000000r 2                       .globalzp YSAV
000000r 2                       .globalzp MODE
000000r 2                       .globalzp MSGL
000000r 2                       .globalzp MSGH
000000r 2               
000000r 1                       .include "acia.inc"
000000r 2                       .import _acia_init
000000r 2                       .import _acia_read_byte
000000r 2                       .import _acia_read_byte_nw
000000r 2                       .import _acia_write_byte
000000r 2                       .import ACIA_STATUS
000000r 2                       .import ACIA_DATA
000000r 2               
000000r 1                       .include "console.inc"
000000r 2                       .import _con_init
000000r 2                       .import _con_in
000000r 2                       .import _con_out
000000r 2                       .import _con_prompt
000000r 2                       .import _con_nl
000000r 2                       .import _con_print
000000r 2               
000000r 1                       .include "sysram.inc"
000000r 2                       .import con_buf
000000r 2                       .import Rbuff
000000r 2                       .import wozmon_buf
000000r 2               
000000r 1               
000000r 1                       .export _xmodem
000000r 1               
000000r 1               SOH     =    $01        ; start block
000000r 1               EOT     =    $04        ; end of text marker
000000r 1               ACK     =    $06        ; good block acknowledged
000000r 1               NAK     =    $15        ; bad block acknowledged
000000r 1               CAN     =    $18        ; cancel (not standard, not supported)
000000r 1               CR      =    $0d        ; carriage return
000000r 1               LF      =    $0a        ; line feed
000000r 1               ESC     =    $1b        ; ESC to exit
000000r 1               
000000r 1                       .code
000000r 1               _xmodem:
000000r 1               XModem:
000000r 1  20 rr rr             jsr    PrintMsg    ; send prompt and info
000003r 1  A9 01                lda    #$01
000005r 1  85 rr                sta    blkno        ; set block # to 1
000007r 1  85 rr                sta    bflag        ; set flag to get address from block 1
000009r 1               StartCrc:
000009r 1  A9 43                lda    #'C'        ; "C" start with CRC mode
00000Br 1  20 rr rr             jsr    Put_Chr        ; send it
00000Er 1  A9 FF                lda    #$FF
000010r 1  85 rr                sta    retry2        ; set loop counter for ~3 sec delay
000012r 1  A9 00                lda    #$00
000014r 1  85 rr                sta    crc
000016r 1  85 rr                sta    crch        ; init CRC value
000018r 1  20 rr rr             jsr    GetByte        ; wait for input
00001Br 1  B0 11                bcs    GotByte        ; byte received, process it
00001Dr 1  90 EA                bcc    StartCrc    ; resend "C"
00001Fr 1               
00001Fr 1               StartBlk:
00001Fr 1  A9 FF                lda    #$FF        ;
000021r 1  85 rr                sta    retry2        ; set loop counter for ~3 sec delay
000023r 1  A9 00                lda    #$00        ;
000025r 1  85 rr                sta    crc        ;
000027r 1  85 rr                sta    crch        ; init CRC value
000029r 1  20 rr rr             jsr    GetByte        ; get first byte of block
00002Cr 1  90 F1                bcc    StartBlk    ; timed out, keep waiting...
00002Er 1               GotByte:
00002Er 1  C9 1B                cmp    #ESC        ; quitting?
000030r 1  D0 01                        bne    GotByte1    ; no
000032r 1               ;        lda    #$FE        ; Error code in "A" of desired
000032r 1  00                           brk            ; YES - do BRK or change to RTS if desired
000033r 1               GotByte1:
000033r 1  C9 01                cmp    #SOH        ; start of block?
000035r 1  F0 07                beq    BegBlk        ; yes
000037r 1  C9 04                cmp    #EOT        ;
000039r 1  D0 51                bne    BadCrc        ; Not SOH or EOT, so flush buffer & send NAK
00003Br 1  4C rr rr             jmp    Done        ; EOT - all done!
00003Er 1               BegBlk:
00003Er 1  A2 00                ldx    #$00
000040r 1               GetBlk:
000040r 1  A9 FF                lda    #$ff        ; 3 sec window to receive characters
000042r 1  85 rr                sta     retry2        ;
000044r 1               GetBlk1:
000044r 1  20 rr rr             jsr    GetByte        ; get next character
000047r 1  90 43                bcc    BadCrc        ; chr rcv error, flush and send NAK
000049r 1               GetBlk2:
000049r 1  9D rr rr             sta    Rbuff,x        ; good char, save it in the rcv buffer
00004Cr 1  E8                   inx            ; inc buffer pointer
00004Dr 1  E0 84                cpx    #$84        ; <01> <FE> <128 bytes> <CRCH> <CRCL>
00004Fr 1  D0 EF                bne    GetBlk        ; get 132 characters
000051r 1  A2 00                ldx    #$00        ;
000053r 1  BD rr rr             lda    Rbuff,x        ; get block # from buffer
000056r 1  C5 rr                cmp    blkno        ; compare to expected block #
000058r 1  F0 07                beq    GoodBlk1    ; matched!
00005Ar 1  20 rr rr             jsr    Print_Err    ; Unexpected block number - abort
00005Dr 1  20 rr rr             jsr    Flush        ; mismatched - flush buffer and then do BRK
000060r 1               ;        lda    #$FD        ; put error code in "A" if desired
000060r 1  00                   brk            ; unexpected block # - fatal error - BRK or RTS
000061r 1               GoodBlk1:
000061r 1  49 FF                eor    #$ff        ; 1's comp of block #
000063r 1  E8                   inx            ;
000064r 1  DD rr rr             cmp    Rbuff,x        ; compare with expected 1's comp of block #
000067r 1  F0 07                beq    GoodBlk2     ; matched!
000069r 1  20 rr rr             jsr    Print_Err    ; Unexpected block number - abort
00006Cr 1  20 rr rr             jsr     Flush        ; mismatched - flush buffer and then do BRK
00006Fr 1               ;        lda    #$FC        ; put error code in "A" if desired
00006Fr 1  00                   brk            ; bad 1's comp of block#
000070r 1               GoodBlk2:
000070r 1  A0 02                ldy    #$02        ;
000072r 1               CalcCrc:
000072r 1  B9 rr rr             lda    Rbuff,y        ; calculate the CRC for the 128 bytes of data
000075r 1  20 rr rr             jsr    UpdCrc        ; could inline sub here for speed
000078r 1  C8                   iny            ;
000079r 1  C0 82                cpy    #$82        ; 128 bytes
00007Br 1  D0 F5                bne    CalcCrc        ;
00007Dr 1  B9 rr rr             lda    Rbuff,y        ; get hi CRC from buffer
000080r 1  C5 rr                cmp    crch        ; compare to calculated hi CRC
000082r 1  D0 08                bne    BadCrc        ; bad crc, send NAK
000084r 1  C8                   iny            ;
000085r 1  B9 rr rr             lda    Rbuff,y        ; get lo CRC from buffer
000088r 1  C5 rr                cmp    crc        ; compare to calculated lo CRC
00008Ar 1  F0 0B                beq    GoodCrc        ; good CRC
00008Cr 1               BadCrc:
00008Cr 1  20 rr rr             jsr    Flush        ; flush the input port
00008Fr 1  A9 15                lda    #NAK        ;
000091r 1  20 rr rr             jsr    Put_Chr        ; send NAK to resend block
000094r 1  4C rr rr             jmp    StartBlk    ; start over, get the block again
000097r 1               GoodCrc:
000097r 1  A2 02                ldx    #$02        ;
000099r 1  A5 rr                lda    blkno        ; get the block number
00009Br 1  C9 01                cmp    #$01        ; 1st block?
00009Dr 1  D0 12                bne    CopyBlk        ; no, copy all 128 bytes
00009Fr 1  A5 rr                lda    bflag        ; is it really block 1, not block 257, 513 etc.
0000A1r 1  F0 0E                beq    CopyBlk        ; no, copy all 128 bytes
0000A3r 1  BD rr rr             lda    Rbuff,x        ; get target address from 1st 2 bytes of blk 1
0000A6r 1  85 rr                sta    ptr        ; save lo address
0000A8r 1  E8                   inx            ;
0000A9r 1  BD rr rr             lda    Rbuff,x        ; get hi address
0000ACr 1  85 rr                sta    ptr+1        ; save it
0000AEr 1  E8                   inx            ; point to first byte of data
0000AFr 1  C6 rr                dec    bflag        ; set the flag so we won't get another address
0000B1r 1               CopyBlk:
0000B1r 1  A0 00                ldy    #$00        ; set offset to zero
0000B3r 1               CopyBlk3:
0000B3r 1  BD rr rr             lda    Rbuff,x        ; get data byte from buffer
0000B6r 1  91 rr                sta    (ptr),y        ; save to target
0000B8r 1  E6 rr                inc    ptr        ; point to next address
0000BAr 1  D0 02                bne    CopyBlk4    ; did it step over page boundary?
0000BCr 1  E6 rr                inc    ptr+1        ; adjust high address for page crossing
0000BEr 1               CopyBlk4:
0000BEr 1  E8                   inx            ; point to next data byte
0000BFr 1  E0 82                cpx    #$82        ; is it the last byte
0000C1r 1  D0 F0                bne    CopyBlk3    ; no, get the next one
0000C3r 1               IncBlk:
0000C3r 1  E6 rr                inc    blkno        ; done.  Inc the block #
0000C5r 1  A9 06                lda    #ACK        ; send ACK
0000C7r 1  20 rr rr             jsr    Put_Chr        ;
0000CAr 1  4C rr rr             jmp    StartBlk    ; get next block
0000CDr 1               Done:
0000CDr 1  A9 06                lda    #ACK        ; last block, send ACK and exit.
0000CFr 1  20 rr rr             jsr    Put_Chr        ;
0000D2r 1  20 rr rr             jsr    Flush        ; get leftover characters, if any
0000D5r 1  20 rr rr             jsr    Print_Good    ;
0000D8r 1  60                   rts            ;
0000D9r 1               ;
0000D9r 1               ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0000D9r 1               ;
0000D9r 1               ; subroutines
0000D9r 1               ;
0000D9r 1               ;                    ;
0000D9r 1               GetByte:
0000D9r 1  A9 00                lda    #$00        ; wait for chr input and cycle timing loop
0000DBr 1  85 rr                sta    retry        ; set low value of timing loop
0000DDr 1               StartCrcLp:
0000DDr 1  20 rr rr             jsr    Get_Chr        ; get chr from serial port, don't wait
0000E0r 1  B0 09                bcs    GetByte1    ; got one, so exit
0000E2r 1  C6 rr                dec    retry        ; no character received, so dec counter
0000E4r 1  D0 F7                bne    StartCrcLp    ;
0000E6r 1  C6 rr                dec    retry2        ; dec hi byte of counter
0000E8r 1  D0 F3                bne    StartCrcLp    ; look for character again
0000EAr 1  18                   clc            ; if loop times out, CLC, else SEC and return
0000EBr 1               GetByte1:
0000EBr 1  60                   rts            ; with character in "A"
0000ECr 1               ;
0000ECr 1               Flush:
0000ECr 1  A9 70                lda    #$70        ; flush receive buffer
0000EEr 1  85 rr                sta    retry2        ; flush until empty for ~1 sec.
0000F0r 1               Flush1:
0000F0r 1  20 rr rr             jsr    GetByte        ; read the port
0000F3r 1  B0 F7                bcs    Flush        ; if chr recvd, wait for another
0000F5r 1  60                   rts            ; else done
0000F6r 1               ;
0000F6r 1               PrintMsg:
0000F6r 1  A2 00                ldx    #$00        ; PRINT starting message
0000F8r 1               PrtMsg1:
0000F8r 1  BD rr rr             lda       Msg,x
0000FBr 1  F0 06                beq    PrtMsg2
0000FDr 1  20 rr rr             jsr    Put_Chr
000100r 1  E8                   inx
000101r 1  D0 F5                bne    PrtMsg1
000103r 1               PrtMsg2:
000103r 1  60                   rts
000104r 1               Msg:
000104r 1  42 65 67 69          .byte    "Begin XMODEM/CRC transfer.  Press <Esc> to abort..."
000108r 1  6E 20 58 4D  
00010Cr 1  4F 44 45 4D  
000137r 1  0D 0A                .byte      CR, LF
000139r 1  00                   .byte   0
00013Ar 1               ;
00013Ar 1               Print_Err:
00013Ar 1  A2 00                ldx    #$00        ; PRINT Error message
00013Cr 1               PrtErr1:
00013Cr 1  BD rr rr             lda       ErrMsg,x
00013Fr 1  F0 06                beq    PrtErr2
000141r 1  20 rr rr             jsr    Put_Chr
000144r 1  E8                   inx
000145r 1  D0 F5                bne    PrtErr1
000147r 1               PrtErr2:
000147r 1  60                   rts
000148r 1               ErrMsg:
000148r 1  55 70 6C 6F          .byte     "Upload Error!"
00014Cr 1  61 64 20 45  
000150r 1  72 72 6F 72  
000155r 1  0D 0A                .byte      CR, LF
000157r 1  00                   .byte   0
000158r 1               ;
000158r 1               Print_Good:
000158r 1  A2 00                ldx    #$00        ; PRINT Good Transfer message
00015Ar 1               Prtgood1:
00015Ar 1  BD rr rr             lda       GoodMsg,x
00015Dr 1  F0 06                beq    Prtgood2
00015Fr 1  20 rr rr             jsr    Put_Chr
000162r 1  E8                   inx
000163r 1  D0 F5                bne    Prtgood1
000165r 1               Prtgood2:
000165r 1  60                   rts
000166r 1               GoodMsg:
000166r 1  55 70 6C 6F          .byte   "Upload Successful!"
00016Ar 1  61 64 20 53  
00016Er 1  75 63 63 65  
000178r 1  0D 0A                .byte   CR, LF
00017Ar 1  00                   .byte   0
00017Br 1               ;
00017Br 1               ;
00017Br 1               ;======================================================================
00017Br 1               ;  I/O Device Specific Routines
00017Br 1               ;
00017Br 1               ;  Two routines are used to communicate with the I/O device.
00017Br 1               ;
00017Br 1               ; "Get_Chr" routine will scan the input port for a character.  It will
00017Br 1               ; return without waiting with the Carry flag CLEAR if no character is
00017Br 1               ; present or return with the Carry flag SET and the character in the "A"
00017Br 1               ; register if one was present.
00017Br 1               ;
00017Br 1               ; "Put_Chr" routine will write one byte to the output port.  Its alright
00017Br 1               ; if this routine waits for the port to be ready.  its assumed that the
00017Br 1               ; character was send upon return from this routine.
00017Br 1               ;
00017Br 1               ; Here is an example of the routines used for a standard 6551 ACIA.
00017Br 1               ; You would call the ACIA_Init prior to running the xmodem transfer
00017Br 1               ; routine.
00017Br 1               ;
00017Br 1               
00017Br 1               ;
00017Br 1               ; input chr from ACIA (no waiting)
00017Br 1               ;
00017Br 1               Get_Chr:
00017Br 1  4C rr rr             jmp _acia_read_byte_nw
00017Er 1               
00017Er 1               ; output to OutPut Port
00017Er 1               ;
00017Er 1               Put_Chr:
00017Er 1  4C rr rr             jmp _acia_write_byte
000181r 1               ;=========================================================================
000181r 1               ;
000181r 1               ;
000181r 1               ;  CRC subroutines
000181r 1               ;
000181r 1               ;
000181r 1               UpdCrc:
000181r 1  45 rr                eor     crc+1         ; Quick CRC computation with lookup tables
000183r 1  AA                   tax             ; updates the two bytes at crc & crc+1
000184r 1  A5 rr                lda     crc        ; with the byte send in the "A" register
000186r 1  5D rr rr             eor     crchi,X
000189r 1  85 rr                sta     crc+1
00018Br 1  BD rr rr             lda     crclo,X
00018Er 1  85 rr                sta     crc
000190r 1  60                   rts
000191r 1               
000191r 1               ;
000191r 1               ; low byte CRC lookup table (should be page aligned)
000191r 1                       .segment "RODATA"
000000r 1               crclo:
000000r 1  00 21 42 63   .byte $00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
000004r 1  84 A5 C6 E7  
000008r 1  08 29 4A 6B  
000010r 1  31 10 73 52   .byte $31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
000014r 1  B5 94 F7 D6  
000018r 1  39 18 7B 5A  
000020r 1  62 43 20 01   .byte $62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
000024r 1  E6 C7 A4 85  
000028r 1  6A 4B 28 09  
000030r 1  53 72 11 30   .byte $53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
000034r 1  D7 F6 95 B4  
000038r 1  5B 7A 19 38  
000040r 1  C4 E5 86 A7   .byte $C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
000044r 1  40 61 02 23  
000048r 1  CC ED 8E AF  
000050r 1  F5 D4 B7 96   .byte $F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
000054r 1  71 50 33 12  
000058r 1  FD DC BF 9E  
000060r 1  A6 87 E4 C5   .byte $A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
000064r 1  22 03 60 41  
000068r 1  AE 8F EC CD  
000070r 1  97 B6 D5 F4   .byte $97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
000074r 1  13 32 51 70  
000078r 1  9F BE DD FC  
000080r 1  88 A9 CA EB   .byte $88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
000084r 1  0C 2D 4E 6F  
000088r 1  80 A1 C2 E3  
000090r 1  B9 98 FB DA   .byte $B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
000094r 1  3D 1C 7F 5E  
000098r 1  B1 90 F3 D2  
0000A0r 1  EA CB A8 89   .byte $EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
0000A4r 1  6E 4F 2C 0D  
0000A8r 1  E2 C3 A0 81  
0000B0r 1  DB FA 99 B8   .byte $DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
0000B4r 1  5F 7E 1D 3C  
0000B8r 1  D3 F2 91 B0  
0000C0r 1  4C 6D 0E 2F   .byte $4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
0000C4r 1  C8 E9 8A AB  
0000C8r 1  44 65 06 27  
0000D0r 1  7D 5C 3F 1E   .byte $7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
0000D4r 1  F9 D8 BB 9A  
0000D8r 1  75 54 37 16  
0000E0r 1  2E 0F 6C 4D   .byte $2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
0000E4r 1  AA 8B E8 C9  
0000E8r 1  26 07 64 45  
0000F0r 1  1F 3E 5D 7C   .byte $1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0
0000F4r 1  9B BA D9 F8  
0000F8r 1  17 36 55 74  
000100r 1               
000100r 1               ; hi byte CRC lookup table (should be page aligned)
000100r 1               crchi:
000100r 1  00 10 20 30   .byte $00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
000104r 1  40 50 60 70  
000108r 1  81 91 A1 B1  
000110r 1  12 02 32 22   .byte $12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
000114r 1  52 42 72 62  
000118r 1  93 83 B3 A3  
000120r 1  24 34 04 14   .byte $24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
000124r 1  64 74 44 54  
000128r 1  A5 B5 85 95  
000130r 1  36 26 16 06   .byte $36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
000134r 1  76 66 56 46  
000138r 1  B7 A7 97 87  
000140r 1  48 58 68 78   .byte $48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
000144r 1  08 18 28 38  
000148r 1  C9 D9 E9 F9  
000150r 1  5A 4A 7A 6A   .byte $5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
000154r 1  1A 0A 3A 2A  
000158r 1  DB CB FB EB  
000160r 1  6C 7C 4C 5C   .byte $6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
000164r 1  2C 3C 0C 1C  
000168r 1  ED FD CD DD  
000170r 1  7E 6E 5E 4E   .byte $7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
000174r 1  3E 2E 1E 0E  
000178r 1  FF EF DF CF  
000180r 1  91 81 B1 A1   .byte $91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
000184r 1  D1 C1 F1 E1  
000188r 1  10 00 30 20  
000190r 1  83 93 A3 B3   .byte $83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
000194r 1  C3 D3 E3 F3  
000198r 1  02 12 22 32  
0001A0r 1  B5 A5 95 85   .byte $B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
0001A4r 1  F5 E5 D5 C5  
0001A8r 1  34 24 14 04  
0001B0r 1  A7 B7 87 97   .byte $A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
0001B4r 1  E7 F7 C7 D7  
0001B8r 1  26 36 06 16  
0001C0r 1  D9 C9 F9 E9   .byte $D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
0001C4r 1  99 89 B9 A9  
0001C8r 1  58 48 78 68  
0001D0r 1  CB DB EB FB   .byte $CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
0001D4r 1  8B 9B AB BB  
0001D8r 1  4A 5A 6A 7A  
0001E0r 1  FD ED DD CD   .byte $FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
0001E4r 1  BD AD 9D 8D  
0001E8r 1  7C 6C 5C 4C  
0001F0r 1  EF FF CF DF   .byte $EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E
0001F4r 1  AF BF 8F 9F  
0001F8r 1  6E 7E 4E 5E  
000200r 1               ;
000200r 1               ;
000200r 1               ; End of File
000200r 1               ;
000200r 1               
